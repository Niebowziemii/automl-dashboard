{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>AutoML Dashboard is a cutting-edge dashboard application tailored for the  M5 competition, revolutionizing how data is visualized and analyzed. As an  open-source tool, it's specifically designed to handle the complex datasets of  the M5 forecasting competition, offering intuitive and interactive visualizations.  AutoML Dashboard streamlines the process of interpreting time series data, enhancing precision and efficiency. This empowers analysts and participants to draw meaningful  conclusions and insights from the competition data, elevating their forecasting  strategies.</p>"},{"location":"contribution-guide.html","title":"Contribution guide","text":"<p>This guide provides rules and examples for writing clean and consistent Python code. Following these guidelines  will help ensure code readability, maintainability, and collaboration within a development team.</p>"},{"location":"contribution-guide.html#code-organization","title":"Code Organization","text":"<p>Well-organized code is easier to navigate and understand. Consider the following guidelines:</p> <ul> <li>Separate different concerns into modules, classes, and functions.</li> <li>Keep each function or method focused on a single task.</li> <li>Group related functions or methods within classes or modules.</li> <li>Use meaningful file and directory names to reflect the purpose of the code.</li> </ul>"},{"location":"contribution-guide.html#adding-new-plots","title":"Adding new plots","text":"<p>To add a new chart, create a Python script file in <code>src/plots</code>.</p> <p>The name of the file is the name of the plot.</p> <p>The file must contain a function named <code>plot</code> with the following signature: <pre><code>def plot(data: dict[str, DataFrame], module: DeltaGenerator, key_s: str) -&gt; None:  # noqa: ARG001\n</code></pre> which will somehow plot something using streamlit.</p> <p>You can see many existing examples in the repository.</p>"},{"location":"contribution-guide.html#branching-strategy","title":"Branching Strategy","text":"<p>Adopting a consistent branching strategy promotes collaboration and code isolation. Follow the structure  <code>feature/{task_id}-{task_name}</code> for each new task branch. For example:</p> <p><code>feature/123-add-user-authentication</code></p> <p>This structure allows for easy identification of the task and ensures a clear separation of code changes. Furthermore there are several important things to remeber:</p> <ul> <li>main branch should be reserved for a production-ready version of the code</li> <li>develop branch should contain latest stable version</li> <li>each merge request should be performed with squash and deletion of the source branch</li> </ul>"},{"location":"contribution-guide.html#docstring-format","title":"Docstring Format","text":"<p>Writing clear and concise docstrings helps others understand your code's purpose and usage. Follow the Google Style  Python Docstrings format, which includes sections for the summary, parameters, return values, and more.  Here's an example: <pre><code>def calculate_sum(a, b):\n    \"\"\"Calculate the sum of two numbers.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        int: The sum of the two numbers.\n    \"\"\"\n    return a + b\n</code></pre></p> <p>Using a consistent docstring format improves code documentation and helps generate accurate API documentation automatically.</p>"},{"location":"contribution-guide.html#commit-format","title":"Commit Format","text":"<p>In this repository we are using the following format of the commit message: <pre><code>&lt;gitmoji&gt; &lt;scope of the changes&gt; &lt;comment&gt;\n</code></pre> Gitmojis can be found HERE</p> <p>It would be nice if your commit was signed and had a verified status but at the moment it is not obligatory: </p> <pre><code>git commit -S -m \"&lt;gitmoji&gt; &lt;scope of the changes&gt; &lt;comment&gt;\"\n</code></pre>"},{"location":"user-guide.html","title":"User guide","text":"<p>This guide provides rules and examples on how to get started with AutoML Dashboard!</p>"},{"location":"user-guide.html#setting-up-the-project","title":"Setting up the project","text":"<p>This guide was created using Windows, if you use other operating system please fill free to contribute to this guide.</p>"},{"location":"user-guide.html#step-1-clone-the-repository","title":"Step 1 Clone the repository","text":"<pre><code>git clone https://github.com/Niebowziemii/automl-dashboard.git\n</code></pre>"},{"location":"user-guide.html#step-2-download-the-data","title":"Step 2 Download the data","text":"<p>Enter the following link: HERE</p> <p>Authorize yourself and click the \"download all\" button to obtain the zip package:</p> <p></p> <p>Extract the downloaded folder in the root of the project and change the name of the folder to <code>input</code></p> <p></p> <pre><code>automl-dashboard\n\u251c\u2500\u2500 input\n\u2502   \u2514\u2500\u2500 m5-forecasting-accuracy\n\u2502       \u251c\u2500\u2500 calendar.csv\n\u2502       \u251c\u2500\u2500 sales_train_evaluation.csv\n\u2502       \u251c\u2500\u2500 sales_train_validation.csv\n\u2502       \u251c\u2500\u2500 sample_submission.csv\n\u2502       \u2514\u2500\u2500 sell_prices.csv\n...\n</code></pre>"},{"location":"user-guide.html#step-3-prepare-the-environment","title":"Step 3 Prepare the environment","text":"<p>This guide was created using <code>python == 3.10.11</code> and PowerShell <pre><code>PS C:\\...\\automl-dashboard&gt; python --version\nPython 3.10.11\n</code></pre></p> <p>Install the package manager in your python (globally or if you use pyenv then only for the selected version) <pre><code>pip install pipenv\n</code></pre></p> <p>Now check if everything works fine <pre><code>PS C:\\...\\automl-dashboard&gt; pipenv --version\npipenv, version 2023.7.11\n</code></pre></p> <p>Use the package manager to install the packages required to run the code: <pre><code>PS C:\\...\\automl-dashboard&gt; pipenv install --dev\nCreating a virtualenv for this project...\nPipfile: C:\\...\\automl-dashboard\\Pipfile\nUsing c:/users/&lt;user&gt;/.pyenv/pyenv-win/versions/3.10.11/python3.exe (3.10.11) to create virtualenv...\n[ ===] Creating virtual environment...created virtual environment CPython3.10.11.final.0-64 in 1266ms\n  creator CPython3Windows(dest=C:\\Users\\&lt;user&gt;\\.virtualenvs\\automl-dashboard-RpLtEANu, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=C:\\Users\\&lt;user&gt;\\AppData\\Local\\pypa\\virtualenv)\n    added seed packages: pip==23.3.1, setuptools==69.0.2, wheel==0.41.3\n  activators BashActivator,BatchActivator,FishActivator,NushellActivator,PowerShellActivator,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: C:\\Users\\&lt;user&gt;\\.virtualenvs\\automl-dashboard-RpLtEANu\nInstalling dependencies from Pipfile.lock (171210)...\nInstalling dependencies from Pipfile.lock (171210)...\nTo activate this project's virtualenv, run pipenv shell.\nAlternatively, run a command inside the virtualenv with pipenv run.\n</code></pre></p>"},{"location":"user-guide.html#step-4-run-the-main","title":"Step 4 Run the main","text":"<p><pre><code>PS C:\\...\\automl-dashboard&gt; pipenv run streamlit run main.py\n\n  You can now view your Streamlit app in your browser.\n\n  Local URL: http://localhost:8501\n  Network URL: http://192.168.0.16:8501\n</code></pre> Click the link and enjoy!</p>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>load</li> <li>plots<ul> <li>calendar_heatmap</li> <li>helper</li> <li>prices_distribution</li> <li>products_correlation</li> <li>sales_distribution</li> <li>sales_heatmap</li> <li>stores_boxplot</li> </ul> </li> </ul>"},{"location":"reference/load.html","title":"load","text":"<p>Loading function.</p>"},{"location":"reference/load.html#src.load.load_files","title":"<code>load_files()</code>","text":"<p>Function loading input data into RAM memory.</p> Source code in <code>src/load.py</code> <pre><code>@st.cache_data()\ndef load_files() -&gt; dict[str, DataFrame]:\n    \"\"\"Function loading input data into RAM memory.\"\"\"\n    directory = \"./input/m5-forecasting-accuracy\"\n    calendar = read_csv(Path(directory, \"calendar.csv\"))\n    stv = read_csv(Path(directory, \"sales_train_validation.csv\"))\n    ste = read_csv(Path(directory, \"sales_train_evaluation.csv\"))\n    sp = read_csv(Path(directory, \"sell_prices.csv\"))\n    ss = read_csv(Path(directory, \"sample_submission.csv\"))\n    return {\"calendar\": calendar, \"stv\": stv, \"ste\": ste, \"sp\": sp, \"ss\": ss}\n</code></pre>"},{"location":"reference/plots/calendar_heatmap.html","title":"calendar_heatmap","text":"<p>Calendar heatmap plot.</p>"},{"location":"reference/plots/calendar_heatmap.html#src.plots.calendar_heatmap.plot","title":"<code>plot(data, module, key_s)</code>","text":"<p>Calendar plot with sales.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, DataFrame]</code> <p>M5 forecasting accuracy dict formatted as in load.py.</p> required <code>module</code> <code>DeltaGenerator</code> <p>Layout element for rendering.</p> required <code>key_s</code> <code>str</code> <p>Key for streamlit components.</p> required Source code in <code>src/plots/calendar_heatmap.py</code> <pre><code>def plot(data: dict[str, DataFrame], module: DeltaGenerator, key_s: str) -&gt; None:\n    \"\"\"Calendar plot with sales.\n\n    Args:\n        data (dict[str, DataFrame]): M5 forecasting accuracy dict formatted as in load.py.\n        module (DeltaGenerator): Layout element for rendering.\n        key_s (str): Key for streamlit components.\n    \"\"\"\n    n = 100\n\n    left_column, rigth_column = module.columns(2)\n\n    available_states = list(data[\"stv\"][\"state_id\"].unique())\n    selected_states = left_column.multiselect(\"Select state:\", available_states, available_states, key=key_s + \"0\")\n\n    available_stores = list(\n        filter(\n            lambda store: store.startswith(tuple(selected_states)),\n            list(data[\"stv\"][\"store_id\"].unique()),\n        )\n    )\n    selected_stores = rigth_column.multiselect(\"Select store:\", available_stores, available_stores, key=key_s + \"1\")\n\n    available_categories = list(data[\"stv\"][\"cat_id\"].unique())\n    selected_categories = left_column.multiselect(\"Select category:\", available_categories, available_categories, key=key_s + \"2\")\n\n    available_subcategories = list(\n        filter(\n            lambda subcategory: subcategory.startswith(tuple(selected_categories)),\n            list(data[\"stv\"][\"dept_id\"].unique()),\n        )\n    )\n    selected_subcategories = rigth_column.multiselect(\n        \"Select subcategory:\",\n        available_subcategories,\n        available_subcategories,\n        key=key_s + \"3\",\n    )\n\n    filtered_stv = data[\"stv\"].query(f\"state_id in {selected_states} &amp; store_id in {selected_stores} &amp; cat_id in {selected_categories} &amp; dept_id in {selected_subcategories}\")\n\n    total_available_days = len(data[\"stv\"].iloc[:, 6:].columns)\n    available_days = data[\"calendar\"][\"date\"].iloc[:total_available_days]\n\n    min_date = datetime.datetime.strptime(available_days.iloc[0], \"%Y-%m-%d\").astimezone()\n\n    max_date = datetime.datetime.strptime(available_days.iloc[-1], \"%Y-%m-%d\").astimezone()\n\n    start_date = left_column.date_input(\n        \"Start date\",\n        min_value=min_date,\n        max_value=max_date,\n        value=min_date,\n        format=\"YYYY-MM-DD\",\n        key=key_s + \"4\",\n    )\n\n    end_date = left_column.date_input(\n        \"End date\",\n        min_value=min_date,\n        max_value=max_date,\n        value=max_date,\n        format=\"YYYY-MM-DD\",\n        key=key_s + \"5\",\n    )\n\n    if len(filtered_stv) == 0:\n        module.warning(\"No data available.\")\n        return\n\n    sample_stv = filtered_stv if len(filtered_stv) &lt; n else filtered_stv.sample(n=n, random_state=42)\n\n    stv_random = sample_stv.drop([\"item_id\", \"dept_id\", \"store_id\", \"state_id\"], axis=1)\n    stv_random = stv_random.drop(columns=[\"cat_id\"])\n    stv_random = cast(DataFrame, stv_random.sum())\n    stv_random = stv_random.iloc[1:].to_frame()  # type: ignore[operator]\n    stv_random = stv_random.rename(columns={0: \"sales\"})\n    stv_random[\"date\"] = available_days.to_list()\n    stv_random = stv_random.set_index(\"date\")\n\n    stv_between_dates = stv_random.loc[str(start_date) : str(end_date)]  # type: ignore[misc]\n    stv_between_dates = stv_between_dates.reset_index()\n\n    fig = calplot(\n        stv_between_dates,\n        x=\"date\",\n        y=\"sales\",\n        dark_theme=True,\n        years_title=True,\n        gap=0,\n        name=\"Sales\",\n        month_lines_width=3,\n        month_lines_color=\"#fff\",\n        colorscale=\"blues\",\n    ).update_xaxes(tickangle=0)\n\n    module.plotly_chart(fig)\n</code></pre>"},{"location":"reference/plots/helper.html","title":"helper","text":"<p>Helper functions for data processing.</p>"},{"location":"reference/plots/helper.html#src.plots.helper.helper_func","title":"<code>helper_func(frame)</code>","text":"<p>Preprocessing function.</p> Source code in <code>src/plots/helper.py</code> <pre><code>def helper_func(frame: DataFrame) -&gt; DataFrame:\n    \"\"\"Preprocessing function.\"\"\"\n    frame = frame.drop([\"item_id\", \"dept_id\", \"cat_id\", \"store_id\", \"state_id\"], axis=1)\n    frame = frame.melt(id_vars=\"id\", var_name=\"dates\", value_name=\"sales\")\n    frame[\"id\"] = frame[\"id\"].str.replace(\"_validation\", \"\")\n    return frame\n</code></pre>"},{"location":"reference/plots/prices_distribution.html","title":"prices_distribution","text":"<p>Prices distribution plot.</p>"},{"location":"reference/plots/prices_distribution.html#src.plots.prices_distribution.plot","title":"<code>plot(data, module, key_s)</code>","text":"<p>Distribution of prices.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing price data.</p> required <code>module</code> <code>DeltaGenerator</code> <p>Layout element for rendering.</p> required <code>key_s</code> <code>str</code> <p>Key for streamlit components.</p> required Source code in <code>src/plots/prices_distribution.py</code> <pre><code>def plot(data: dict[str, DataFrame], module: DeltaGenerator, key_s: str) -&gt; None:\n    \"\"\"Distribution of prices.\n\n    Args:\n        data (DataFrame): DataFrame containing price data.\n        module (DeltaGenerator): Layout element for rendering.\n        key_s (str): Key for streamlit components.\n    \"\"\"\n    available_states = list(data[\"stv\"][\"state_id\"].unique())\n    selected_states = module.multiselect(\"Select state:\", available_states, available_states, key=key_s + \"0\")\n\n    available_stores = list(\n        filter(\n            lambda store: store.startswith(tuple(selected_states)),\n            list(data[\"stv\"][\"store_id\"].unique()),\n        )\n    )\n    selected_stores = module.multiselect(\"Select store:\", available_stores, available_stores, key=key_s + \"1\")\n\n    available_categories = list(data[\"stv\"][\"cat_id\"].unique())\n    selected_categories = module.multiselect(\"Select category:\", available_categories, available_categories, key=key_s + \"2\")\n\n    available_subcategories = list(\n        filter(\n            lambda subcategory: subcategory.startswith(tuple(selected_categories)),\n            list(data[\"stv\"][\"dept_id\"].unique()),\n        )\n    )\n    selected_subcategories = module.multiselect(\"Select subcategory:\", available_subcategories, available_subcategories, key=key_s + \"3\")\n\n    min_date = data[\"calendar\"][data[\"calendar\"][\"wm_yr_wk\"] == data[\"sp\"][\"wm_yr_wk\"].min()][\"date\"].to_numpy()[0]\n    max_date = data[\"calendar\"][data[\"calendar\"][\"wm_yr_wk\"] == data[\"sp\"][\"wm_yr_wk\"].max()][\"date\"].to_numpy()[-1]\n    min_date = datetime.datetime.strptime(min_date, \"%Y-%m-%d\").astimezone()\n    max_date = datetime.datetime.strptime(max_date, \"%Y-%m-%d\").astimezone()\n\n    start_date = module.date_input(\"Start date\", min_value=min_date, max_value=max_date, value=min_date, format=\"YYYY-MM-DD\", key=key_s + \"5\")\n    end_date = module.date_input(\"End date\", min_value=min_date, max_value=max_date, value=max_date, format=\"YYYY-MM-DD\", key=key_s + \"6\")\n\n    # chack type of start_date and end_date:\n    if type(start_date) == datetime.date and type(end_date) == datetime.date:\n        start_date = data[\"calendar\"][data[\"calendar\"][\"date\"] == start_date.strftime(\"%Y-%m-%d\")][\"wm_yr_wk\"].to_numpy()[0]\n        end_date = data[\"calendar\"][data[\"calendar\"][\"date\"] == end_date.strftime(\"%Y-%m-%d\")][\"wm_yr_wk\"].to_numpy()[-1]\n    else:\n        start_date, end_date = None, None\n\n    filtered_sp = data[\"sp\"][\n        (data[\"sp\"][\"wm_yr_wk\"] &gt;= start_date)\n        &amp; (data[\"sp\"][\"wm_yr_wk\"] &lt;= end_date)\n        &amp; data[\"sp\"][\"store_id\"].isin(selected_stores)\n        &amp; data[\"sp\"][\"item_id\"].str.startswith(tuple(selected_subcategories))\n    ]\n\n    if len(filtered_sp) == 0:\n        module.warning(\"No data available.\")\n        return\n\n    # Choose aggregation type\n    aggregation_type = module.radio(\"Choose Aggregation Type\", [\"Min\", \"Max\", \"Average\"], key=key_s + \"4\")\n\n    if aggregation_type == \"Min\":\n        filtered_sp = filtered_sp.groupby(\"item_id\")[\"sell_price\"].min().reset_index()\n    elif aggregation_type == \"Max\":\n        filtered_sp = filtered_sp.groupby(\"item_id\")[\"sell_price\"].max().reset_index()\n    elif aggregation_type == \"Average\":\n        filtered_sp = filtered_sp.groupby(\"item_id\")[\"sell_price\"].mean().reset_index()\n\n    maximum_value = 31\n\n    fig = go.Figure()\n    fig.update_layout(\n        title_text=\"Distribution of sell prices\",\n        xaxis_title_text=\"Sell price (in Dollars)\",\n        yaxis_title_text=\"Count\",\n        bargap=0.2,  # gap between bars of adjacent location coordinates.\n        bargroupgap=0.1,  # gap between bars of the same location coordinate.\n        xaxis={\n            \"tickmode\": \"array\",\n            \"tickvals\": list(range(maximum_value + 1)),\n            \"ticktext\": [str(i) for i in range(maximum_value)] + list(\"&gt;\"),\n        },\n    )\n\n    fig.add_trace(\n        go.Histogram(\n            x=[np.minimum(maximum_value, num) for num in filtered_sp[\"sell_price\"]],\n            xbins={\"size\": 1},\n        )\n    )\n\n    module.plotly_chart(fig)\n</code></pre>"},{"location":"reference/plots/products_correlation.html","title":"products_correlation","text":"<p>Products correlation plot.</p>"},{"location":"reference/plots/products_correlation.html#src.plots.products_correlation.plot","title":"<code>plot(data, module, key_s)</code>","text":"<p>SCorrelation of random sample of products.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, DataFrame]</code> <p>M5 forecasting accuracy dict formatted as in load.py.</p> required <code>module</code> <code>DeltaGenerator</code> <p>Layout element for rendering.</p> required <code>key_s</code> <code>str</code> <p>Key for streamlit components.</p> required Source code in <code>src/plots/products_correlation.py</code> <pre><code>def plot(data: dict[str, DataFrame], module: DeltaGenerator, key_s: str) -&gt; None:\n    \"\"\"SCorrelation of random sample of products.\n\n    Args:\n        data (dict[str, DataFrame]): M5 forecasting accuracy dict formatted as in load.py.\n        module (DeltaGenerator): Layout element for rendering.\n        key_s (str): Key for streamlit components.\n    \"\"\"\n    n = 100\n\n    left_column, rigth_column = module.columns(2)\n\n    available_states = list(data[\"stv\"][\"state_id\"].unique())\n    selected_states = left_column.multiselect(\"Select state:\", available_states, available_states, key=key_s + \"0\")\n\n    available_stores = list(\n        filter(\n            lambda store: store.startswith(tuple(selected_states)),\n            list(data[\"stv\"][\"store_id\"].unique()),\n        )\n    )\n    selected_stores = left_column.multiselect(\"Select store:\", available_stores, available_stores, key=key_s + \"1\")\n\n    available_categories = list(data[\"stv\"][\"cat_id\"].unique())\n    selected_categories = rigth_column.multiselect(\"Select category:\", available_categories, available_categories, key=key_s + \"2\")\n\n    available_subcategories = list(\n        filter(\n            lambda subcategory: subcategory.startswith(tuple(selected_categories)),\n            list(data[\"stv\"][\"dept_id\"].unique()),\n        )\n    )\n    selected_subcategories = rigth_column.multiselect(\n        \"Select subcategory:\",\n        available_subcategories,\n        available_subcategories,\n        key=key_s + \"3\",\n    )\n\n    filtered_stv = data[\"stv\"].query(f\"state_id in {selected_states} &amp; store_id in {selected_stores} &amp; cat_id in {selected_categories} &amp; dept_id in {selected_subcategories}\")\n\n    if len(filtered_stv) == 0:\n        module.warning(\"No data available.\")\n        return\n\n    stv_ = filtered_stv if len(filtered_stv) &lt; n else filtered_stv.sample(n=n, random_state=42)\n    stv_random = stv_.drop([\"id\", \"dept_id\", \"cat_id\", \"store_id\", \"state_id\"], axis=1)\n    stv_random = stv_random.groupby(\"item_id\").sum()\n    stv_random = stv_random.iloc[:, 1:]\n    corr = stv_random.T.corr()\n    corr = corr.fillna(0)\n    fig = px.imshow(\n        corr,\n        color_continuous_scale=px.colors.sequential.Turbo,\n        title=f\"Correlation between random {n} Products\",\n        labels={\"x\": \"\", \"y\": \"\", \"color\": \"Correlation\"},\n    )\n    fig.update_yaxes(showticklabels=False)\n    fig.update_xaxes(showticklabels=False)\n    module.plotly_chart(fig)\n</code></pre>"},{"location":"reference/plots/sales_distribution.html","title":"sales_distribution","text":"<p>Sales distribution plot.</p>"},{"location":"reference/plots/sales_distribution.html#src.plots.sales_distribution.plot","title":"<code>plot(data, module, key_s)</code>","text":"<p>Distribution of sales.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, DataFrame]</code> <p>M5 forecasting accuracy dict formatted as in load.py.</p> required <code>module</code> <code>DeltaGenerator</code> <p>Layout element for rendering.</p> required <code>key_s</code> <code>str</code> <p>Key for streamlit components.</p> required Source code in <code>src/plots/sales_distribution.py</code> <pre><code>def plot(data: dict[str, DataFrame], module: DeltaGenerator, key_s: str) -&gt; None:\n    \"\"\"Distribution of sales.\n\n    Args:\n        data (dict[str, DataFrame]): M5 forecasting accuracy dict formatted as in load.py.\n        module (DeltaGenerator): Layout element for rendering.\n        key_s (str): Key for streamlit components.\n    \"\"\"\n    n = 1000\n    left_column, rigth_column = module.columns(2)\n\n    available_states = list(data[\"stv\"][\"state_id\"].unique())\n    selected_states = left_column.multiselect(\"Select state:\", available_states, available_states, key=key_s + \"0\")\n\n    available_stores = list(\n        filter(\n            lambda store: store.startswith(tuple(selected_states)),\n            list(data[\"stv\"][\"store_id\"].unique()),\n        )\n    )\n    selected_stores = left_column.multiselect(\"Select store:\", available_stores, available_stores, key=key_s + \"1\")\n\n    available_categories = list(data[\"stv\"][\"cat_id\"].unique())\n    selected_categories = rigth_column.multiselect(\"Select category:\", available_categories, available_categories, key=key_s + \"2\")\n\n    available_subcategories = list(\n        filter(\n            lambda subcategory: subcategory.startswith(tuple(selected_categories)),\n            list(data[\"stv\"][\"dept_id\"].unique()),\n        )\n    )\n    selected_subcategories = rigth_column.multiselect(\n        \"Select subcategory:\",\n        available_subcategories,\n        available_subcategories,\n        key=key_s + \"3\",\n    )\n\n    filtered_stv = data[\"stv\"].query(f\"state_id in {selected_states} &amp; store_id in {selected_stores} &amp; cat_id in {selected_categories} &amp; dept_id in {selected_subcategories}\")\n\n    if len(filtered_stv) == 0:\n        module.warning(\"No data available.\")\n        return\n\n    sample_stv = filtered_stv if len(filtered_stv) &lt; n else filtered_stv.sample(n=n, random_state=42)\n\n    merged = helper_func(sample_stv).merge(data[\"calendar\"], how=\"left\", left_on=\"dates\", right_on=\"d\")\n\n    merged_ = DataFrame(merged.groupby(\"date\")[\"sales\"].sum()).reset_index()\n\n    fig = px.line(\n        merged_,\n        x=\"date\",\n        y=\"sales\",\n        title=f\"Sales over time of random {n} products\",\n        labels={\"date\": \"Date\", \"sales\": \"Sales\"},\n        render_mode=\"webg1\",\n    )\n\n    fig.update_xaxes(\n        rangeslider_visible=True,\n        rangeselector={\n            \"buttons\": [\n                {\"count\": 1, \"label\": \"1m\", \"step\": \"month\", \"stepmode\": \"backward\"},\n                {\"count\": 3, \"label\": \"3m\", \"step\": \"month\", \"stepmode\": \"backward\"},\n                {\"count\": 6, \"label\": \"6m\", \"step\": \"month\", \"stepmode\": \"backward\"},\n                {\"count\": 1, \"label\": \"1y\", \"step\": \"year\", \"stepmode\": \"backward\"},\n                {\"step\": \"all\"},\n            ]\n        },\n    )\n\n    fig.update_layout(\n        template=\"plotly_dark\",\n        xaxis_rangeselector_font_color=\"white\",\n        xaxis_rangeselector_activecolor=\"red\",\n        xaxis_rangeselector_bgcolor=\"black\",\n    )\n\n    module.plotly_chart(fig)\n</code></pre>"},{"location":"reference/plots/sales_heatmap.html","title":"sales_heatmap","text":"<p>Sales heatmap plot.</p>"},{"location":"reference/plots/sales_heatmap.html#src.plots.sales_heatmap.plot","title":"<code>plot(data, module, key_s)</code>","text":"<p>Sales heatmap of smaples over time.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, DataFrame]</code> <p>M5 forecasting accuracy dict formatted as in load.py.</p> required <code>module</code> <code>DeltaGenerator</code> <p>Layout element for rendering.</p> required <code>key_s</code> <code>str</code> <p>Key for streamlit components.</p> required Source code in <code>src/plots/sales_heatmap.py</code> <pre><code>def plot(data: dict[str, DataFrame], module: DeltaGenerator, key_s: str) -&gt; None:\n    \"\"\"Sales heatmap of smaples over time.\n\n    Args:\n        data (dict[str, DataFrame]): M5 forecasting accuracy dict formatted as in load.py.\n        module (DeltaGenerator): Layout element for rendering.\n        key_s (str): Key for streamlit components.\n    \"\"\"\n    n = 100\n\n    left_column, rigth_column = module.columns(2)\n\n    available_states = list(data[\"stv\"][\"state_id\"].unique())\n    selected_states = left_column.multiselect(\"Select state:\", available_states, available_states, key=key_s + \"0\")\n\n    available_stores = list(\n        filter(\n            lambda store: store.startswith(tuple(selected_states)),\n            list(data[\"stv\"][\"store_id\"].unique()),\n        )\n    )\n    selected_stores = rigth_column.multiselect(\"Select store:\", available_stores, available_stores, key=key_s + \"1\")\n\n    available_categories = list(data[\"stv\"][\"cat_id\"].unique())\n    selected_categories = left_column.multiselect(\"Select category:\", available_categories, available_categories, key=key_s + \"2\")\n\n    available_subcategories = list(\n        filter(\n            lambda subcategory: subcategory.startswith(tuple(selected_categories)),\n            list(data[\"stv\"][\"dept_id\"].unique()),\n        )\n    )\n    selected_subcategories = rigth_column.multiselect(\n        \"Select subcategory:\",\n        available_subcategories,\n        available_subcategories,\n        key=key_s + \"3\",\n    )\n\n    filtered_stv = data[\"stv\"].query(f\"state_id in {selected_states} &amp; store_id in {selected_stores} &amp; cat_id in {selected_categories} &amp; dept_id in {selected_subcategories}\")\n\n    total_available_days = len(data[\"stv\"].iloc[:, 6:].columns)\n    available_days = data[\"calendar\"][\"date\"].iloc[:total_available_days]\n\n    min_date = datetime.datetime.strptime(available_days.iloc[0], \"%Y-%m-%d\").astimezone()\n\n    max_date = datetime.datetime.strptime(available_days.iloc[-1], \"%Y-%m-%d\").astimezone()\n\n    start_date = left_column.date_input(\n        \"Start date\",\n        min_value=min_date,\n        max_value=max_date,\n        value=min_date,\n        format=\"YYYY-MM-DD\",\n        key=key_s + \"4\",\n    )\n\n    end_date = left_column.date_input(\n        \"End date\",\n        min_value=min_date,\n        max_value=max_date,\n        value=max_date,\n        format=\"YYYY-MM-DD\",\n        key=key_s + \"5\",\n    )\n\n    if len(filtered_stv) == 0:\n        module.warning(\"No data available.\")\n        return\n\n    stv_ = filtered_stv if len(filtered_stv) &lt; n else filtered_stv.sample(n=n, random_state=42)\n    stv_random = stv_.drop([\"id\", \"dept_id\", \"cat_id\", \"store_id\", \"state_id\"], axis=1)\n    stv_random = stv_random.groupby(\"item_id\").sum()\n    stv_random.columns = stv_random.columns.map(lambda x: (min_date + datetime.timedelta(days=int(x[2:]) - 1)).date())\n    column_start_index = stv_random.columns.get_loc(start_date)\n    column_end_index = stv_random.columns.get_loc(end_date)\n    stv_random = stv_random.iloc[:, column_start_index:column_end_index]\n    fig = px.imshow(\n        stv_random,\n        color_continuous_scale=px.colors.sequential.Turbo,\n        title=f\"Sales Heatmap of random {n} samples\",\n        labels={\"x\": \"Days\", \"y\": \"Products\", \"color\": \"Sales\"},\n    )\n    fig.update_yaxes(showticklabels=False)\n    module.plotly_chart(fig, use_container_width=True)\n</code></pre>"},{"location":"reference/plots/stores_boxplot.html","title":"stores_boxplot","text":"<p>Stores boxplot.</p>"},{"location":"reference/plots/stores_boxplot.html#src.plots.stores_boxplot.plot","title":"<code>plot(data, module, key_s)</code>","text":"<p>Sales per store per category of random n Samples.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, DataFrame]</code> <p>M5 forecasting accuracy dict formatted as in load.py.</p> required <code>module</code> <code>DeltaGenerator</code> <p>Layout element for rendering.</p> required <code>key_s</code> <code>str</code> <p>Key for streamlit components.</p> required Source code in <code>src/plots/stores_boxplot.py</code> <pre><code>def plot(data: dict[str, DataFrame], module: DeltaGenerator, key_s: str) -&gt; None:\n    \"\"\"Sales per store per category of random n Samples.\n\n    Args:\n        data (dict[str, DataFrame]): M5 forecasting accuracy dict formatted as in load.py.\n        module (DeltaGenerator): Layout element for rendering.\n        key_s (str): Key for streamlit components.\n    \"\"\"\n    left_column, rigth_column = module.columns(2)\n\n    total_available_days = len(data[\"stv\"].iloc[:, 6:].columns)\n    available_days = data[\"calendar\"][\"date\"].iloc[:total_available_days]\n\n    min_date = datetime.datetime.strptime(available_days.iloc[0], \"%Y-%m-%d\").astimezone()\n\n    max_date = datetime.datetime.strptime(available_days.iloc[-1], \"%Y-%m-%d\").astimezone()\n\n    start_date = left_column.date_input(\n        \"Start date\",\n        min_value=min_date,\n        max_value=max_date,\n        value=min_date,\n        format=\"YYYY-MM-DD\",\n        key=key_s + \"4\",\n    )\n\n    end_date = rigth_column.date_input(\n        \"End date\",\n        min_value=min_date,\n        max_value=max_date,\n        value=max_date,\n        format=\"YYYY-MM-DD\",\n        key=key_s + \"5\",\n    )\n    n = 1000\n    stv_ = data[\"stv\"].sample(n=n, random_state=42)\n    stv_random = stv_.drop([\"id\", \"item_id\", \"dept_id\", \"state_id\"], axis=1)\n    stv_random = stv_random.melt(id_vars=[\"store_id\", \"cat_id\"], var_name=\"date\", value_name=\"sales\")\n    stv_random = stv_random.groupby([\"store_id\", \"cat_id\", \"date\"]).sum().reset_index()\n    stv_random[\"date\"] = stv_random[\"date\"].map(lambda x: (min_date + datetime.timedelta(days=int(x[2:]) - 1)).date())\n    stv_random = stv_random.loc[(stv_random[\"date\"] &gt;= start_date) &amp; (stv_random[\"date\"] &lt;= end_date)]\n    fig = px.box(\n        stv_random,\n        x=\"store_id\",\n        y=\"sales\",\n        color=\"cat_id\",\n        title=f\"Sales per store per category of random {n} samples\",\n        labels={\"x\": \"Store\", \"y\": \"Sales in different days\"},\n    )\n    module.plotly_chart(fig, use_container_width=True)\n</code></pre>"}]}